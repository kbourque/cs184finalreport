<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
    div.padded {
        padding-top: 0px;
        padding-right: 50px;
        padding-bottom: 0.25in;
        padding-left: 50px;
    }

    html {
        font-family: 'Source Sans Pro', sans-serif;
        color: #332C2C;
    }

    .code {
        font-family: 'Cousine', monospace;
        font-size: 14px;
        font-weight: 600;
        color: olivedrab;
    }

    h1 {
        font-size: 30px;
    }

    h2 {
        font-size: 24px;
    }

    h3 {
        text-transform: uppercase;
        font-size: 20px;
        padding-top: 20px;
    }

    h4 {
        font-size: 18px;
    }

    figcaption {
        padding-top: 10px;
        font-weight: 200;
        font-size: 16px;
    }

</style>
    <title>CS 184 Mesh Editor</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Lato|Source+Sans+Pro:200,200i,300,300i,400,400i,600,600i,700,900" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
<h1 align="middle">Final Project: Fluid Simulation</h1>
<h2 align="middle">Kimberly Bourque, CS184-ads</h2>
<h2 align="middle">Karuna Wadhera, CS184-xxx</h2>
<h2 align="middle">Ashley Chen, CS184-xxx</h2>

<br><br>

<div class="padded">

    <div>
        <h2>Abstract</h2>
        <p>
            We implemented a 3D particle-based method of fluid simulation that addresses issues from SPH methods such as enforcing incompressibility and energy loss.
             We chose this project because fluid simulation is widely used in animation, and we thought it was going to be an intriguing challenge to implement because 
             of the heavy computation used. We used Macklin and Muller’s paper as a guide for implementing particle constraints, and 
             built off of the cloth simulator project code.
        </p>
    </div>

    <div>
        <h2>Technical Approach</h2>

        <div>
            <h3>Implementing Theory</h3>

            <div align="center">
                <table style="width=90%; margin-top: 30px; margin-bottom: 30px;">
                    <tr>
                        <td align="middle">
                            <img src="img/simulate.png" width="40%" />
                            <figcaption align="middle">
                              Simulation Step Code
                            </figcaption>
                        </td>
                    </tr>
                </table>
            </div>
            
            <p>
                During each simulation step, we would first build a spatial map to find each particle’s set of neighbors, 
                and apply external forces, then for a number of iterations we would calculate the scaling factor, <b>lambda</b>, and 
                perform a position update with both lambda and the artificial pressure <b>s_corr</b>. Finally, after detecting collisions, 
                we would update our velocity with changed positions and apply vorticity and viscosity for the next iteration.
            </p>


            <div>
                <h4>Finding neighbors</h4>
                <p>
                        Many of the next sections calculate position and velocity of a PointMass (particle) based on different aspects of their neighbors. 
                        We found that the optimal number of neighbors for each particle turned out to be around 20-30.
                </p>

                <p>
                        To assign point mass neighbors, we created used a map; the keys were a spatial hash of the point masses based on their x, y and z positions, 
                        and the values were a list of PointMasses that mapped to the same hash. The purpose of this was to divide the volume into sectors and map PointMasses 
                        to sectors so that we didn’t have to consider every particle when checking for neighbors, but only the particles in the same sector.  
                        Each PointMass struct contains a <span class="code">std::vector<PointMass*></span> neighbors that is updated every time step.
                </p>

                <div align="center">
                    <table style="width=90%; margin-top: 30px; margin-bottom: 30px;">
                        <tr>
                            <td align="middle">
                                <img src="img/neighbors.png" width="60%" />
                                <figcaption align="middle">
                                  Hash function for spatial map
                                </figcaption>
                            </td>
                        </tr>
                    </table>
                </div>
                
            </div>

            <div>
                    <h4>Detecting Collisions</h4> 
                    <p>
                        We added collision detection before setting the finalized positions of particles at the end of each step to ensure that no particles traveled through any objects in the scene, 
                        like planes or spheres.  To implement collisions we corrected the predicted position so that if a particle wouldn’t go past the bounds of the collision object plus a constant 
                        <span class="code">SURFACE_OFFSET</span> (this is so the points lay just beside the object and not directly on it to prevent any rendering ambiguity).  
                    </p>                  
            </div>

            <div>
                <h4>Enforcing Incompressibility</h4>
                <p>
                        The goal of each simulation step is to predict each particle’s new position based on external forces and density constraints.  
                        The density constraints (there is one non-linear constraint per particle) are solved for over several iterations with Newton’s method.  
                        Once the density constraints, indicated by <span class="code">lambda</span>, are finalized for each particle, they are applied to the calculation of the predicted position.  
                </p>
                <div align="center">
                        <table style="width=90%; margin-top: 30px; margin-bottom: 30px;">
                            <tr>
                                <td align="middle">
                                    <img src="img/lambda.png" width="60%" />
                                    <figcaption align="middle">
                                      Lambda
                                    </figcaption>
                                </td>
                            </tr>
                        </table>
                </div>
            </div>

            <div>
                <h4>Adding Tensile Instability</h4>
                <p>
                        One problem mentioned in Macklin’s paper that SPH simulations suffer from is clumping from when a neighbor doesn’t have enough neighbors can’t satisfy the rest density.  
                        To combat this we followed the approach in the paper of adding an artificial pressure term, which we call s_corr.  
                        This term is included in the calculation of delta_p, the new position and imitates the effects of surface tension by making particles draw their neighbors towards them.
                </p>
                <div align="center">
                        <table style="width=90%; margin-top: 30px; margin-bottom: 30px;">
                            <tr>
                                <td align="middle">
                                    <img src="img/posupdate.png" width="40%" />
                                    <figcaption align="middle">
                                      Position update including lambda and artificial pressure
                                    </figcaption>
                                </td>
                            </tr>
                            <tr>
                                    <td align="middle">
                                        <img src="img/correctiveforce.png" width="60%" />
                                        <figcaption align="middle">
                                          <span class="code">s_corr</span>
                                        </figcaption>
                                    </td>
                                </tr>
                        </table>
                </div>
            </div>

            <div>
                    <h4>Vorticity Confinement</h4>

                    <p>
                            To address the issue of dampening and lost energy from SPH methods of fluid simulation, 
                            we calculate the vorticity of each particle’s location and a corrective force based on that vorticity. 
                    </p>

                    <div align="center">
                            <table style="width=90%; margin-top: 30px; margin-bottom: 30px;">
                                <tr>
                                    <td align="middle">
                                        <img src="img/vorticity.png" width="40%" />
                                    </td>
                                </tr>
                                <tr>
                                        <td align="middle">
                                            <img src="img/fvorticity.png" width="40%" />
                                        </td>
                                    </tr>
                                    <tr>
                                            <td align="middle">
                                                <img src="img/n.png" width="40%" />
                                            </td>
                                        </tr>
                            </table>
                    </div>

                    <p>
                            We also added viscosity in order to simulate a thicker consistency. We followed the approach in the PBD paper for both of these. 
                            We chose a value of 0.01 for <span class="code">c</span>.
                    </p>

                    <div align="center">
                            <table style="width=90%; margin-top: 30px; margin-bottom: 30px;">
                                <tr>
                                    <td align="middle">
                                        <img src="img/viscosity.png" width="60%" />
                                    </td>
                                </tr>
                            </table>
                    </div>
            </div>
        </div>
    </div>

    <div>
        <h2>Results</h2>
    </div>

    <div>
        <h2>References</h2>
        <ul>
            <li><a href="http://mmacklin.com/pbf_sig_preprint.pdf">Position Based Fluid Simulation Paper</a></li>
            <li><a href="http://www.interactive-graphics.de/PositionBasedDynamics/doc/html/">Position Based Dynamics Framework Documentation</a></li>
            <li><a href="http://mmacklin.com/EG2015PBD.pdf">Tutorial on PBD, Macklin</a></li>
            <li><a href="https://arxiv.org/pdf/1007.1245.pdf">Original Smoothed Particle Dynamics Paper</a></li>
            <li><a href="http://developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf">Screen Space Fluid Rendering Resource</a></li>
            <li><a href="http://on-demand.gputechconf.com/gtc/2014/presentations/S4117-fast-fixed-radius-nearest-neighbor-gpu.pdf">Particle Neighbor Finding Optimization</a></li>
            <li><a href="https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/sphsurvivalkit.pdf">SPH Survival Kit</a></li>
            <li><a href="https://github.com/wjakob/nanogui">NanoGui</a></li>
            <li><a href="http://mmacklin.com/pbf_slides.pdf">Macklin Slides</a></li>
        </ul>
    </div>

    <div>
        <h2>Contributions</h2>
    </div>
</div>





</body>
</html>
