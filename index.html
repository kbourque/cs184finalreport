<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
    div.padded {
        padding-top: 0px;
        padding-right: 50px;
        padding-bottom: 0.25in;
        padding-left: 50px;
    }

    html {
        font-family: 'Source Sans Pro', sans-serif;
        color: #332C2C;
    }

    .code {
        font-family: 'Cousine', monospace;
        font-size: 14px;
        font-weight: 600;
        color: olivedrab;
    }

    h1 {
        font-size: 30px;
    }

    h2 {
        font-size: 24px;
    }

    h3 {
        text-transform: uppercase;
        font-size: 18px;
        padding-top: 20px;
    }

    figcaption {
        font-weight: 200;
    }

</style>
    <title>CS 184 Mesh Editor</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Lato|Source+Sans+Pro:200,200i,300,300i,400,400i,600,600i,700,900" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
<h1 align="middle">Final Project: Fluid Simulation</h1>
<h2 align="middle">Kimberly Bourque, CS184-ads</h2>
<h2 align="middle">Karuna Wadhera, CS184-xxx</h2>
<h2 align="middle">Ashley Chen, CS184-xxx</h2>

<br><br>

<div class="padded">

    <div>
        <h2>Abstract</h2>
        <p>
            We implemented a 3D particle-based method of fluid simulation that addresses issues from SPH methods such as enforcing incompressibility and energy loss.
             We chose this project because fluid simulation is widely used in animation, and we thought it was going to be an intriguing challenge to implement because 
             of the heavy computation used. We used Macklin and Muller’s paper as a guide for implementing particle constraints, and 
             built off of the cloth simulator project code.
        </p>
    </div>

    <div>
        <h2>Technical Approach</h2>

        <div>
            <h3>Implementing Theory</h3>

            <div align="center">
                <table style="width=90%; margin-top: 30px; margin-bottom: 30px;">
                    <tr>
                        <td align="middle">
                            <img src="img/simulate.png" width="40%" />
                            <figcaption align="middle">
                              Simulation Step Code
                            </figcaption>
                        </td>
                    </tr>
                </table>
            </div>
            
            <p>
                During each simulation step, we would first build a spatial map to find each particle’s set of neighbors, 
                and apply external forces, then for a number of iterations we would calculate the scaling factor, <b>lambda</b>, and 
                perform a position update with both lambda and the artificial pressure <b>s_corr</b>. Finally, after detecting collisions, 
                we would update our velocity with changed positions and apply vorticity and viscosity for the next iteration.
            </p>

            <h4>Finding neighbors</h4>

            <div>
                Many of the next sections calculate position and velocity of a PointMass (particle) based on different aspects of their neighbors. 
                We found that the optimal number of neighbors for each particle turned out to be around 20-30.
                
                To assign point mass neighbors, we created used a map; the keys were a spatial hash of the point masses based on their x, y and z positions, 
                and the values were a list of PointMasses that mapped to the same hash. The purpose of this was to divide the volume into sectors and map PointMasses 
                to sectors so that we didn’t have to consider every particle when checking for neighbors, but only the particles in the same sector.  
                Each PointMass struct contains a <span class="code">std::vector<PointMass*></span> neighbors that is updated every time step.

                <div align="center">
                    <table style="width=90%; margin-top: 30px; margin-bottom: 30px;">
                        <tr>
                            <td align="middle">
                                <img src="img/neighbors.png" width="60%" />
                                <figcaption align="middle">
                                  Hash function for spatial map
                                </figcaption>
                            </td>
                        </tr>
                    </table>
                </div>
                
            </div>
        </div>
    </div>

    <div>
        <h2>Results</h2>
    </div>

    <div>
        <h2>References</h2>
        <ul>
            <li><a href="http://mmacklin.com/pbf_sig_preprint.pdf">Position Based Fluid Simulation Paper</a></li>
            <li><a href="http://www.interactive-graphics.de/PositionBasedDynamics/doc/html/">Position Based Dynamics Framework Documentation</a></li>
            <li><a href="http://mmacklin.com/EG2015PBD.pdf">Tutorial on PBD, Macklin</a></li>
            <li><a href="https://arxiv.org/pdf/1007.1245.pdf">Original Smoothed Particle Dynamics Paper</a></li>
            <li><a href="http://developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf">Screen Space Fluid Rendering Resource</a></li>
            <li><a href="http://on-demand.gputechconf.com/gtc/2014/presentations/S4117-fast-fixed-radius-nearest-neighbor-gpu.pdf">Particle Neighbor Finding Optimization</a></li>
            <li><a href="https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/sphsurvivalkit.pdf">SPH Survival Kit</a></li>
            <li><a href="https://github.com/wjakob/nanogui">NanoGui</a></li>
            <li><a href="http://mmacklin.com/pbf_slides.pdf">Macklin Slides</a></li>
        </ul>
    </div>

    <div>
        <h2>Contributions</h2>
    </div>
</div>





</body>
</html>
